extends layout

block content
  script(src='/js/vendor/jquery.js')
  .el.title-slide(data-body-class="dark")
    img(style='float:left;', src='/img/waterfall1.gif')  
    h1 Go with the flow
    h3: em Backbone and Streams
    div(style='height:8rem;') &nbsp;
    .note
      :markdown
        ### Did you turn off your screensaver?
        
        Ladies and gentlemen, thank you all for coming. My name is Ryan Muller, and
        I'm a software engineer at Novartis Institutes for Biomedical Research. I
        write software that makes it easier for the scientists there to perform their
        pharmaceutical research.

        I'm here to talk about functional reactive programming and how you can leverage
        it in your Backbone applications. Before I dive in, though, I'm going to very
        briefly introduce functional programming to set the stage for some of the points
        I want to make later.
  .el(data-body-class='dark')
    h4 Functional programming
    blockquote#func-p1.
      Functional programming is a paradigm that treats computation as the evaluation of
      mathematical functions and avoids state changes and mutable data.
    small.el(style="float:right"): em &mdash;Wikipedia
    .note.
      Very brief overview: The official definition of FP is that it's a paradigm that
      treats computation as the evaluation of mathematical functions and avoids state
      changes and mutable data. I don't really like that definition, but it's from
      Wikipedia, so it must be true.
    .el
      blockquote(style="clear:both;").
        Functional programming is a style of programming where functions take input and
        produce output without changing anything outside those functions.
      .note.
        My definition is that functional programming is a style of programming where 
        functions take input and produce output without changing anything outside 
        those functions.
      small(style="float:right"): em &mdash;me
  .el(data-body-class='dark')
    table(style="width:100%;")
      tr: td(colspan=2): h4 Imperative vs. functional
      tr
        td(style="width:50%;"): .el
          h5 Imperative
          pre.
            var list = getListSomehow(),
              newList = [];
            for(var i = 0; i &lt; list; i++){
              newList[i] = list[i] + 1;
            }
        td(style="width:50%;"): .el
          h5 Functional
          pre.
            var list = getListSomehow(),
              newList = list.map(x =&gt; x+1)
    .note
      :markdown
        Here's a quick code sample. Let's say we have a list of numbers, and we want
        to generate a new list whose values are one greater than those in the old list.
        On the left we have the imperative version, or the "Java" version if you like.
        Pretty familiar; loop through the list and increment your variables.
        
        On the right we have the functional version. To create the new list, we simply
        `map` over the old one. We go from our imperative version, in which we have to
        keep track of state (in this case the `i` variable) to a declarative version,
        which feels a little like "magic in, magic out".
  .el(data-body-class='dark')
    h3 In <em>declarative programming,</em> the focus is on <strong>what you want to do</strong>.
    h3 In <em>imperative programming,</em> the focus is on <strong>how you want to do it</strong>.
    .note
      :markdown
        This is the main difference between imperative and functional programming.
        In functional programming, which is declarative, the focus is on <em>what you want to do</em>;
        in imperative programming, the focus is on <em>how you want to do it</em>.
  .el(data-body-class='dark')
    h4 The vocabulary of Underscore
    .note.
      In 2010, we got the 1.0 release of Underscore, which brought all these lovely functional bits
      to JavaScript. We gained a powerful vocabulary that allowed us to specify just what we want
      to do, and rely on Underscore to take care of the fiddly details. We've got:
    div.defs
      .el
        h5 map
        p Converts values
        .note
          :markdown
            map to convert values
            filter to remove values
            reduce to summarize, and so on, and so forth.
      .el
        h5 filter
        p Removes values
      .el
        h5 reduce
        p Summarizes values
      .el
        h5 findWhere
        p Locates values
      .el
        h5 any
        p Checks existence of values
        .note
          :markdown
            To me, functional reactive programming (FRP) is a very natural next step. The BaconJS
            documentation looks very much like the Underscore documentation, in that it gives us
            a vocabulary with which we build programs. Once you get used to using this vocabulary,
            though, you do get a bit spoiled. Personally, when I switch from BaconJS to plain 
            JavaScript it feels a little like I'm writing assembly code, just because I get used to
            these abstractions that Bacon gives me.
            
            I've talked enough about Bacon; now I'm going to give you all some examples.
            
            The central primitive in functional reactive programming is usually called an Observable
            or a Signal. I prefer the term "immutable stream" because it fully describes what you're
            working with.
  .el(data-body-class="dark")
    h3
      :markdown
        A _stream_ is a series of related **events** and **errors** that **may terminate**.
    .note
      :markdown
        _Streams_ are pretty straightforward: a stream
        is a series of related events and errors that may terminate. Here's an
        example:
  .el
    #key-stream
    .note
      :markdown
        This is a stream of `keyup` events, which is very easy to generate using Bacon.
        
        Events can wrap any JavaScript value: booleans, numbers, objects, and even
        Bacon streams.
        
        <input>
    .el
      #sample-error
      .note
        :markdown
          Streams may also have errors in them. Let's suppose for a second that the
          stream here represents a particularly unreliable weather API. The X's
          represent AJAX errors, which you would want to handle differently in your
          application. It's Bacon's try/catch. If you're used to promises, just think
          of a stream as a promise that can resolve more than once.
    .el
      #sample-end
      script(type='x/on-enter').
        var weather3 = Bacon.fromBinder(weatherBinder()).name('weather').take(3);
        weather3.asBubbleStream({element:'#sample-end'});
      .note
        :markdown
          Finally, we have a stream here that emits a couple of values, then ends.
          Once a stream has ended, it emits a special "end" event and nothing more.
          
          Now, I mentioned that these are immutable. You can't change a stream once
          you've created it, but you can perform operations on streams to create
          new ones, in precisely the same way you operate over collections using Underscore.
  .el
    #weather-good
    .note
      :markdown
        So here we've got another weather report stream. Really this is all just random numbers, but
        suppose for a minute.
    .el
      #weather-filter
      .note
        :markdown
          Now I've taken it and filtered it to create a slightly
          nicer weather forecast. If it's colder than 41 degrees out, then I don't
          want to know. Our original stream hasn't been altered at all, we've just created 
          a new one with the information we're interested in.
    .el
      #weather-map
      .note
        :markdown
          Now we take that and format it slightly. We can take this stream and
          update a `div` directly with it; Bacon's API gives us...
    .el
      code: pre.
        weather.filter(t =&gt; (t &gt;= 41))
          .map(t =&gt; t+"&amp;deg; F")
          .assign($('#temp-display'),'html');
      h3(style="float:right;position:absolute;top:-0.5rem;right:0;padding-top:0;")#temp-display
      .note
        :markdown
          ...an easy way to directly update our `div`. You can take a stream and use `assign` on
          it to make it have side-effects; in this case, updating HTML content.
  .el
    #scan-1
    .el
      script(type='x/on-enter') showScan();
      #scan-2
    .note
      :markdown
        Reduce also has a parallel in Bacon: it's `scan`. Here I'm taking a stream of numbers and
        using scan to create a real-time updating sum. There's also another function called
        `reduce` which will wait until your stream closes and emit a single reduced value. Both are
        analagous to Underscore's `reduce` function, it's just that `scan` constantly updates and
        `reduce` emits a single value at the end. Both are useful in different scenarios.
        
        One point I'd like to make about `scan` is that it creates a special kind of stream which
        Bacon calls a Property. Properties and streams are very similar, but conceptually they 
        differ. A stream is considered to be a series of discrete, separate events, whereas a
        Property is one continuous value that changes over time. Bacon treats them mostly the same,
        but there are a couple of cases in which they differ.
        
        Bacon also provides us with a couple of ways to combine events from multiple streams.
  .el
    h5: code .merge()
    script(type='x/on-enter') showMergeExample();
    script(type='x/on-exit') hideMergeExample();
    #merge-ex1
    .el#merge-ex2
    .el#merge-ex3
    .note
      :markdown
        There's `merge()`, which grabs events from both streams. Here we've got a stream of red A's
        and a stream of blue B's, and `merge` creates a new stream with all events on it. This is
        useful for instance if you have a search box with a button next to it. If you want to create
        a stream of enter key presses and button clicks, `merge` is your function.
  .el
    h5: code .combine()
    script(type='x/on-enter') showCombineExample();
    script(type='x/on-exit') hideCombineExample();
    #combine-ex1
    .el#combine-ex2
    .el#combine-ex3
    .note
      :markdown
        There's also `combine()`, which allows you to run a function on the latest event from each
        stream to create your events. Here it's grabbing the color from the first stream and the
        number from the second.
        
        I'm not going to bore you all with the *entire* API here, but there's one higher-level 
        method you need to understand if you're going
        to do anything useful with Bacon: `flatMap()`. `flatMap()` takes a stream where each
        event is itself a stream, and puts all the values from all the streams it sees onto
        a single stream. I know that sounds a little cryptic, so here's an example.
  .el
    h5: code .flatMap()
    script(type='x/on-enter') showFlatMapExample();
    script(type='x/on-exit') hideFlatMapExample();
    #flatmap-ex-urls
    .note
      :markdown
        Suppose we're getting URLs somehow---user input, some automated event
        perhaps, it doesn't matter.
    .el
      //#flatmap-ex-ajax-streams
      img(src='/img/metastream.png')
      .note
        :markdown
          We take these, and we map each URL to an AJAX call. An AJAX call is a perfect example
          of why a stream is a promise with added functionality. You make the request, and what
          you receive back is a representation of a future potential for response or error.
          Bacon actually has a utility function that converts a promise into a Bacon stream, so
          you can use it almost without thinking.
          
          You can see here that each URL has been mapped to a stream. I've just drawn the AJAX
          streams as arrows here, since it would get way out of control if I tried to actually
          make and animate streams within the events.
    .el
      #flatmap-ex-ajax-flat
      .note
        :markdown
          Finally, we use `flatMap` to take all our replies and flatten them into one stream.
          This is how you would generate a stream of weather updates, for instance, like I
          showed earlier.
  .el
    code: pre(style='text-align:center;').
      map() filter() reduce() scan() flatMap()
      delay() throttle() bufferingThrottle()
    .note
      :markdown
        All this vocabulary---`map`, `filter`, `merge`, `flatMap`, and friends---makes up
        almost a domain-specific language. Naturally, this is one reason why you may want
        to consider *not* using FRP; it makes it a bit more difficult for people to jump
        into your codebase.
        
        In addition, the fact that all streams are immutable after creation means that you
        really can't think about problems in the same way. You no longer think in terms of
        past, present, and future; I find that you're sort of stuck in a perpetual present
        and are more concerned with "what's going on over here" and "what's going on over
        there". This is another issue with FRP and Bacon, specifically that it's got a high
        barrier to entry.
        
        For these reasons, Bacon works best on new projects, not on updates. Of course, you
        could use Bacon to update a legacy project, but---especially if someone else is
        working on the same code---it could potentially bar other people from modifying your
        code. (Of course, sometimes that's a good thing.)
        
        > There's another way in which Bacon can be quite a lot to adjust to: when you tend
        > to make extensive use of closures. Whenever you're converting code with a lot of
        > variables being passed through closures, you'll need to either make streams for
        > groups of variables depending on how they're being used, or else 
        
        There are basically infinite ways you can incorporate Bacon and Backbone, much like
        there are nearly infinite ways to use Backbone by itself.
  .el#bb-stream-slide
    script(type='x/on-enter').
      Bacon.interval(2500, 'Backbone.Model')
        .name('stream of models')
        .asBubbleStream({element:'#model-stream'});
    script(type='x/on-exit').
      $('#bb-stream-slide .stream').html('');
    #model-stream
    .note
      :markdown
        One of the simplest is to use a stream of models to update a View. This is really nice
        when you have a very simple model, such as a model that knows about temperature and
        cloud cover, for example. However, if they all fundamentally represent the same thing,
        you might want to consider...
    .el
      #model-event-stream
      script(type='x/on-enter').
        Bacon.interval(2500, 'change')
          .name('model.asEventStream("change")')
          .asBubbleStream({element:'#model-event-stream'})
      
      .note
        :markdown
          ...using one model, and passing events to your View. This is another dead-simple model,
          and probably most familiar to those of you who use...
    .el
      code: pre model.on('change', () =&gt; view.render(model.toJSON()))
      .note
        :markdown
          ...something like this. The Bacon version of that is this:
    .el
      code: pre.
        model.asEventStream('change').onValue( () =&gt; view.render(model.toJSON()))
      .note
        :markdown
          Or, to avoid re-rendering your entire view when you don't have to, maybe when you see an
          update you perform a jQuery selection and only update a particular portion of your view. 
          You can replace that with this:
    .el
      #model-event-field-stream
      script(type='x/on-enter').
        Bacon.repeatedly(2500, ['foo','bar','baz'])
          .name('model.asEventStream("change:fieldname")')
          .asBubbleStream({element:'#model-event-field-stream'})
      code: pre.
        model.asEventStream('change:name')
          .onValue( () =&gt; view.$('.name').text(model.get('name')))
      .note
        :markdown
          This gives you really fine-grained control over your updates, and you can render only the
          parts of your view that have changed.
          
          Now, these examples in and of themselves are fairly useless. The power comes when you want
          to compose them or modify them. If you already have your application running on streams,
          it becomes trivial to change the way the streams flow through your application.
  .el(data-body-class='dark')
    .note Ok. Let's make an app.
  .el(data-body-class='dark')
    h2 Chat server API
    p
      :markdown
        * **GET** `/api/messages?since=<timestamp>` -- fetches messages sent to the server since the given time
        * **GET** `/api/user-events?since=<timestamp>` -- fetches user joins/leaves and statuses
        * **POST** `/api/message` `<message text>` -- post a message
        * **POST** `/api/typing` -- tell the server that the user is typing
        * **POST** `/api/status` `<status text>` -- update status
    .note
      :markdown
        Suppose you've got an API like this one that's already been written. In reality, WebSockets
        would be the way to go, but for the sake of example, our app is going to work by polling.
        Our chat app is just going to be one big chat room for the sake of simplicity.
  .el
    code: pre.
      Message = Backbone.Model.extend({
        send: function() {
          return $.post('/api/message', this.get('content'));
        }
      });
  .el
    script.
      $(function(){
        window.socket.on('custom', function(data){
          console.log(data);
          if(data.initHilite){
            console.log('#init-hilite-'+data.initHilite);
            $('#chat-thread').addClass('dim');
            $('#chat-thread span').css({color:''});
            $('#init-hilite-'+data.initHilite).css({color:'#05a'});
          }
        });
      });
    code#chat-thread: pre.
      ChatThread = Backbone.Collection.extend({
        initialize: function() {<span id="init-hilite-1">
          this.lastSync = this.asEventStream('request')
            .scan(0, () =&gt; + new Date());</span><span id="init-hilite-2">
          this.poll = Bacon.interval(2000);</span><span id="init-hilite-3">
          return this.lastSync
            .sampledBy(this.poll)</span><span id="init-hilite-4">
            .map(function(time) {
              return "/api/messages?since=" + time;
            })</span><span id="init-hilite-5">.flatMap( (url) =&gt; {
              this.trigger('request');
              return Bacon.fromPromise($.getJSON(url));
            })</span><span id="init-hilite-6">.flatMap(function(messages) {
              return Bacon.fromArray(messages.map(function(json) {
                return new Message(json);
              }));
            })</span><span id="init-hilite-7">.assign(this, 'push');</span>
        }
      });
    .note
      .ui.vertical.buttons
        .ui.green.button(onclick="socket.emit('custom',{initHilite:1})") this.lastSync = ...
        .ui.teal.button(onclick="socket.emit('custom',{initHilite:2})") this.poll = ...
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:3})") ...sampledBy
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:4})") ...map
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:5})") ...flatMap
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:6})") ...map
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:7})") ...assign
    .el
      script(type='x/on-enter').
        $('#chat-thread').addClass('dim');
      script(type='x/on-exit').
        $('#chat-thread').removeClass('dim');
  .el
    code: pre.
      ChatThread = Backbone.Collection.extend
        initialize: -&gt;
          @lastSync = @asEventStream('request')
            .scan 0, -&gt; +new Date()
          @poll = Bacon.interval 5000
          @lastSync.sampledBy @poll
            .map (time) -&gt; "/api/messages?since=\#{time}"
            .flatMap (url) -&gt;
              Bacon.fromPromise $.getJSON(url)
            .flatMap (messages) -&gt;
              Bacon.fromArray messages.map (json) -&gt;
                new Message(json)
            .assign @, 'push'
  .el
    script(type='x/on-enter').
      $('#chat-box').slideDown();
      var chatThread = new ChatThread();
      var view = new ChatThreadView({collection:chatThread});
      $('#chat-box').append(view.$el);
      $('#chat-box').append((new EntryView()).render().$el)
  .el
    h5 Further reading
    .el
      h5
        :markdown
          [Intro to Reactive Programming](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)
      .note.
        Intro to Reactive Programming is a gist that explains from the ground up what FRP is in
        straightforward language. 
    .el
      h5 
        :markdown
          [BaconJS documentation](http://baconjs.github.io)
    .el: h5
      :markdown
        [RxJS](http://reactive-extensions.github.io/RxJS/)
      .note
        :markdown
          RxJS is another implementation of FRP, and the one that the Intro to Reactive Programming
          I've listed above uses for its examples.
    .el: h5
      :markdown
        [Elm](http://elm-lang.org/)
      .note
        :markdown
          Elm is a little language designed entirely around functional reactive programming. Elm
          gives you these extremely short ways of writing functional reactive programs that compile
          to JavaScript and run in the browser. Some of the examples are almost as hard to read as 
          Haskell programs, but they're very beautiful little programs.
    .el: h5
      :markdown
        [js-csp](https://github.com/jlongster/js-csp)
      .note
        :markdown
          Finally, js-csp is a representative of another wildly different form of event handling.
          It implements the communicating sequential processes paradigm, which looks a lot like
          Goroutines, if anyone's played around with Google's Go language. I thought I'd include it
          here in case any of you have already decided you don't like functional reactive and would
          like to see what other directions you can explore for event handling.
          
          That's the whole presentation. I hope I've given you all a good overview of BaconJS,
          how it plays nicely with Backbone, why you may or may not want to use it, and how to use
          it. If anyone has any questions now, I'll be glad to take them.
        
  .shows-over End of presentation.
  
  .ui.segment(style="display:none;")#chat-box
    .ui.top.attached.label Chat thread
    //.ui.bottom.attached.label.field(style="padding:0;")
      .ui.small.action.input(style="width:100%;")
        input(type="text", placeholder="Type your message")
        .primary.ui.button Send
  
  script(src='/socket.io/socket.io.js')
  script(src='/js/vendor/Bacon.js')
  script(src='/js/vendor/underscore.js')
  script(src='/js/vendor/backbone.js')
  script(src='/js/backbone.eventstreams.js')
  script(src='/js/keychar.js')
  script(src='/js/bubbles.js')
  script(src='/js/prez.js')
  script(src='/js/chat.js')
