extends layout

block content
  script(src='/js/vendor/jquery.js')
  .el.title-slide(data-body-class="dark")
    img(style='float:left;', src='/img/waterfall1.gif')  
    h1 Go with the flow
    h3: em Backbone and Streams
    h5: a(href="http://twitter.com/_baconscript") @_baconscript
    div(style='height:8rem;') &nbsp;
    .note
      :markdown
        My name is Ryan Muller, and
        I'm a software engineer at Novartis. My job there is to write software that supports the
        scientists in their drug discovery research. Our engineering department makes use of
        Backbone in a wide array of projects.

        I'm here to talk about functional reactive programming and how you can leverage
        it in your Backbone applications. Before I dive in, though, I'm going to very
        briefly introduce functional programming to set the stage for some of the points
        I want to make later.
  .el(data-body-class='dark')
    h4 Functional programming
    blockquote#func-p1.
      Functional programming is a paradigm that treats computation as the evaluation of
      mathematical functions and avoids state changes and mutable data.
    small.el(style="float:right"): em &mdash;Wikipedia
    .note.
      Very brief overview: The official definition of FP is that it's a paradigm that
      treats computation as the evaluation of mathematical functions and avoids state
      changes and mutable data. I don't really like that definition, but it's from
      Wikipedia, so it must be true.
    .el
      blockquote(style="clear:both;").
        Functional programming is a style of programming where functions take input and
        produce output without changing anything outside those functions.
      small(style="float:right"): em &mdash;me
      .note.
        My definition is that functional programming is a style of programming where 
        functions take input and produce output without changing anything outside 
        those functions.
  //.el(data-body-class='dark')
    center(style="width:100%;"): img(src='/img/terrarium.jpg', style='max-height: 40%;')
    .note.
      It's like a sealed terrarium: the little ecosystem in a terrarium is entirely dependent on what you
      put into it at the beginning. If you put too few plants or too little water, the ecosystem
      will turn out very differently than if you put in the right number of plants or the right
      amount of water. More importantly, the terrarium won't change global state. You won't have vines
      growing all over your kitchen or bugs in your bedroom. It's entirely self-contained, just like
      a pure function.
  .el(data-body-class='dark')
    table(style="width:100%;")
      tr: td(colspan=2): h4 Imperative vs. functional
      tr
        td(style="width:50%;"): .el
          h5 Imperative
          pre.
            var list = getListSomehow(),
              sum = 0,
              average;
            for(var i = 0; i &lt; list; i++){
              sum += list[i];
            }
            average = sum / list.length;
        td(style="width:50%;"): .el
          h5 Functional
          pre.
            var list = getListSomehow(),
              average = list
                .reduce((a,b) =&gt; a+b)
                  / list.length;
    .note
      :markdown
        Here's a quick code sample. Let's say we want to take the average of a list of numbers.
        On the right we have the imperative version. We're responsible for keeping track of state
        through the loop, in this case using the `i` and `sum` variables.
        
        On the right we have the functional version. To create the new list, we simply
        `reduce` over the old one. You can see that we use this `reduce` function to neatly tuck
        away all the details, and we're not left creating these temporary variables. This is a very
        simple example; if you really want to see differences between declarative and imperative,
        just find some code that's been written in Java and in Scala. The two languages each encourage
        a very different style of coding.
  .el(data-body-class='dark')
    h3 In <em>declarative programming,</em> the focus is on <strong>what you want to do</strong>.
    h3 In <em>imperative programming,</em> the focus is on <strong>how you want to do it</strong>.
    .note
      :markdown
        My example highlights the main difference between imperative and functional programming.
        In functional programming, which is declarative, the focus is on <em>what you want to do</em>;
        in imperative programming, the focus is on <em>how you want to do it</em>.
  .el(data-body-class='dark')
    h4 The vocabulary of Underscore
    .note.
      In 2010, we got the 1.0 release of Underscore, which brought all these lovely functional bits
      to JavaScript. We gained a powerful vocabulary that allowed us to specify just what we want
      to do, and rely on Underscore to take care of the fiddly details. We've got:
    div.defs
      .el
        h5 map
        p Converts values
        .note
          :markdown
            map to convert values
            filter to remove values
            reduce to summarize, and so on, and so forth.
      .el
        h5 filter
        p Removes values
      .el
        h5 reduce
        p Summarizes values
      .el
        h5 findWhere
        p Locates values
      .el
        h5 any
        p Checks existence of values
        .note
          :markdown
            To me, functional reactive programming (FRP) is a very natural next step. The BaconJS
            documentation looks very much like the Underscore documentation, in that it gives us
            a vocabulary with which we build programs. Once you get used to using this vocabulary,
            though, you do get a bit spoiled. Personally, when I switch from BaconJS to plain 
            JavaScript it feels a little like I'm writing assembly code, just because I get used to
            these abstractions that Bacon gives me.
            
            I've talked enough about things other than BaconJS; now I'm going to give you all some 
            examples.
  .el(data-body-class='dark')
    .note
      :markdown
        The central primitive in functional reactive programming is usually called an Observable
        or a Signal. I prefer the term "immutable stream" because it fully describes what you're
        working with.
  .el(data-body-class="dark")
    h3
      :markdown
        A _stream_ is a series of related **events** and **errors** that **may terminate**.
    .note
      :markdown
        _Streams_ are pretty straightforward: a stream
        is a series of related events and errors that may terminate. Here's an
        example:
  .el
    #key-stream
    .note
      :markdown
        This is a stream of `keyup` events, which is very easy to generate using Bacon.
        
        Events can wrap any JavaScript value: booleans, numbers, objects, and even
        Bacon streams.
        
        <input>
    .el
      #sample-error
      .note
        :markdown
          Streams may also have errors in them. Let's suppose for a second that the
          stream here represents a particularly unreliable weather API. The X's
          represent AJAX errors, which you would want to handle differently in your
          application. It's Bacon's try/catch. If you're used to promises, just think
          of a stream as a promise that can resolve more than once.
    .el
      #sample-end
      script(type='x/on-enter').
        var weather3 = Bacon.fromBinder(weatherBinder()).name('weather').take(3);
        weather3.asBubbleStream({element:'#sample-end'});
      .note
        :markdown
          Finally, we have a stream here that emits a couple of values, then ends.
          Once a stream has ended, it emits a special "end" event and nothing more.
          
          Now, I mentioned that these are immutable. You can't change a stream once
          you've created it, but you can perform operations on streams to create
          new ones, in precisely the same way you operate over collections using Underscore.
  .el
    #weather-good
    .note
      :markdown
        So here we've got another weather report stream. Really this is all just random numbers, but
        suppose for a minute.
    .el
      #weather-filter
      .note
        :markdown
          Now I've taken it and filtered it to create a slightly
          nicer weather forecast. If it's colder than 41 degrees out, then I don't
          want to know. Our original stream hasn't been altered at all, we've just created 
          a new one with the information we're interested in.
    .el
      #weather-map
      .note
        :markdown
          Now we take that and format it slightly. We can take this stream and
          update a `div` directly with it; Bacon's API gives us...
    .el
      code: pre.
        weather.filter(t =&gt; (t &gt;= 41))
          .map(t =&gt; t+"&amp;deg; F")
          .assign($('#temp-display'),'html');
      h3(style="float:right;position:absolute;top:-0.5rem;right:0;padding-top:0;")#temp-display
      .note
        :markdown
          ...an easy way to directly update our `div`. You can take a stream and use `assign` on
          it to make it have side-effects; in this case, updating HTML content.
  .el
    #scan-1
    .el
      script(type='x/on-enter') showScan();
      #scan-2
    .note
      :markdown
        Reduce also has a parallel in Bacon: it's `scan`. Here I'm taking a stream of numbers and
        using scan to create a real-time updating sum. There's also another function called
        `reduce` which will wait until your stream closes and emit a single reduced value. Both are
        analagous to Underscore's `reduce` function, it's just that `scan` constantly updates and
        `reduce` emits a single value at the end. Both are useful in different scenarios.
        
        One point I'd like to make about `scan` is that it creates a special kind of stream which
        Bacon calls a Property. Properties and streams are very similar, but conceptually they 
        differ. A stream is considered to be a series of discrete, separate events, whereas a
        Property is one continuous value that changes over time. Bacon treats them mostly the same,
        but there are a couple of cases in which they differ.
        
        Bacon also provides us with a couple of ways to combine events from multiple streams.
  .el
    h5: code .merge()
    script(type='x/on-enter') showMergeExample();
    script(type='x/on-exit') hideMergeExample();
    #merge-ex1
    .el#merge-ex2
    .el#merge-ex3
    .note
      :markdown
        There's `merge()`, which grabs events from both streams. Here we've got a stream of red A's
        and a stream of blue B's, and `merge` creates a new stream with all events on it. This is
        useful for instance if you have a search box with a button next to it. If you want to create
        a stream of enter key presses and button clicks, `merge` is your function.
    .el 
      .ui.small.action.input(style="width:100%;")
        input(type="text", placeholder="Enter search term")
        .orange.ui.button Search
      .code: pre.
        $('search-field').asEventStream('keyup')
          .filter(x =&gt; x.keyCode === 13)
          .merge( $('#search-btn').asEventStream('click') )
          .onValue(search);
  .el
    h5: code .combine()
    script(type='x/on-enter') showCombineExample();
    script(type='x/on-exit') hideCombineExample();
    #combine-ex1
    .el#combine-ex2
    .el#combine-ex3
    .note
      :markdown
        There's also `combine()`, which allows you to run a function on the latest event from each
        stream to create your events. Here it's grabbing the color from the first stream and the
        number from the second.
        
        I'm not going to bore you all with the *entire* API here, but there's one higher-level 
        method you need to understand if you're going
        to do anything useful with Bacon: `flatMap()`. `flatMap()` takes a stream where each
        event is itself a stream, and puts all the values from all the streams it sees onto
        a single stream. I know that sounds a little cryptic, so here's an example.
  .el
    h5: code .flatMap()
    script(type='x/on-enter') showFlatMapExample();
    script(type='x/on-exit') hideFlatMapExample();
    #flatmap-ex-urls
    .note
      :markdown
        Suppose we're getting URLs somehow---user input, some automated event
        perhaps, it doesn't matter.
    .el
      //#flatmap-ex-ajax-streams
      center(style="width:100%;"): img(src='/img/metastream.png')
      .note
        :markdown
          We take these, and we map each URL to an AJAX call. An AJAX call is a perfect example
          of why a stream is a promise with added functionality. You make the request, and what
          you receive back is a representation of a future potential for response or error.
          Bacon actually has a utility function that converts a promise into a Bacon stream, so
          you can use it almost without thinking.
          
          I could have done this example as an animation like the others as well, but frankly I
          couldn't get it to look right with CSS, so here's a static image.
          
          You can see here that each URL has been mapped to a stream. I've just drawn the AJAX
          streams as arrows here, since it would get way out of control if I tried to actually
          make and animate streams within the events.
    .el
      #flatmap-ex-ajax-flat
      .note
        :markdown
          Finally, we use `flatMap` to take all our replies and flatten them into one stream.
          This is how you would generate a stream of weather updates, for instance, like I
          showed earlier.
  .el
    code: pre(style='text-align:center;').
      map() filter() reduce() scan() 
      take() diff()
      flatMap() flatMapLatest()
      delay() throttle() bufferingThrottle()
    .note
      :markdown
        All this vocabulary---`map`, `filter`, `merge`, `flatMap`, and friends---makes up
        almost a whole new language in its own right, with its own control flow. The fact that you have this new control
        flow means you have to fundamentally attack your problems in a different way. Naturally, this is one reason why
        you may want to consider *not* using FRP. It's got a steep initial learning curve. Because the streams are
        immutable, you have to get away from the idea of variables and focus more on events. It's awesome once you've
        mastered the basic concepts, but until then it sucks a bit. I can compare it to learning Vim or Emacs---you're
        going to go through a period of really horrible non-productivity while you're learning, but then once you've
        paid your dues you gain these superpowers.
        
        A side effect of this is that you also have to learn the vocabulary. If you sit down and read through the
        documentation a couple of times, you'll get a good feel for the types of things Bacon does and does not do.
        Again, to compare it to Underscore: when I was learning Underscore, I'd think of a function like `every()` or
        `any()` that just seemed like it was the "kind of function" that Underscore "would have", and I'd check the
        docs and sure enough I'd find it. Bacon has the same kind of thing where you get a feel for it and you learn
        the types of functions that Bacon might provide. I guess, to stick with the theme of the conference, you could
        say that Bacon has a flavor.
        
        Now, pure functional programming is great if you're an academic, but ultimately you really do need to have some
        effect on the real world. &rarr;
  .el
    center(style="position:fixed;top:0;bottom:0;left:0;right:0;vertical-align:middle;")
      <blockquote class="twitter-tweet" lang="en"><p>This is your reminder that the DOM is actually a giant, mutable, global variable in the middle of your program. Act accordingly.</p>&mdash; Marco Rogers (@polotek) <a href="https://twitter.com/polotek/status/543590973846999040">December 13, 2014</a></blockquote>
      <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
    .note
      :markdown
        &rarr; As the joke goes, the reason pure functional programs have no global effects is
        because nobody runs them. As a result &rarr;
  .el(data-body-class='dark')
    h4 The Great Divide
    table(style='width:100%;'): tr
      td(style='width:50%;border-right:1px solid white;')
        h5 Bacon streams
      td(style='width:50%;')
        h5 Backbone
    .note
      :markdown
        &rarr; you need to have some place in your application where you stop using functional programming and start
        having some sort of global state. By far, the easiest place to do this division is to have Bacon.js handle
        internals, and to have Backbone models keep track of their own state. Bacon becomes this sort of tucked-away
        plumbing, and your Backbone models simply work.
        
        I'm going to now go through a few recipes for combining Bacon with Backbone: some good, some bad. I'm starting
        off with the bad one.
  .el#bb-stream-slide
    script(type='x/on-enter').
      Bacon.interval(2500, 'Backbone.Model')
        .name('stream of models')
        .asBubbleStream({element:'#model-stream'});
    script(type='x/on-exit').
      $('#bb-stream-slide .stream').html('');
    #model-stream
    .note
      :markdown
        One of the simplest is to use a stream of models to update a View. This is honestly a little insulting to
        Backbone. You've got these rich models which know things about themselves and can update themselves on the
        server, and here they're performing the same essential task as a plain JavaScript hash could. A better
        way is to...
  .el
    #model-event-stream
    script(type='x/on-enter').
      Bacon.interval(2500, 'change')
        .name('model.asEventStream("change")')
        .asBubbleStream({element:'#model-event-stream'})
    .note
      :markdown
        ...use one model, and passing events to your View. This is another dead-simple model,
        and probably most familiar to those of you who use...
    .el
      code: pre model.on('change', () =&gt; view.render(model.toJSON()))
      .note
        :markdown
          ...something like this. The Bacon version of that is this:
    .el
      code: pre.
        model.asEventStream('change')
          .onValue( () =&gt; view.render(model.toJSON()))
      .note
        :markdown
          This is useful for updating your views, but it's also useful if you have multiple people pontentially editing
          a resource and you want to prevent conflicts. If instead of updating a view, you want to sync with a server,
          you can send these change events. If the server is receiving change events from multiple users, then you can
          decide at the server level how to resolve any conflicts and send the results back out to the users.
          
          In the context of the previous talk, you could actually even write your events to localStorage during any
          period when your app is offline. When your app reconnects with the server, it can just send up all the events
          from localStorage, and the server can decide what to do about conflicts at that point.
          
          Or, to avoid re-rendering your entire view when you don't have to, maybe when you see an
          update you perform a jQuery selection and only update a particular portion of your view. 
          You can replace that with this:
    .el
      #model-event-field-stream
      script(type='x/on-enter').
        Bacon.repeatedly(2500, ['foo','bar','baz'])
          .name('model.asEventStream("change:fieldname")')
          .asBubbleStream({element:'#model-event-field-stream'})
      code: pre.
        model.asEventStream('change:name')
          .onValue( () =&gt; view.$('.name').text(model.get('name')))
      .note
        :markdown
          This gives you really fine-grained control over your updates, and you can render only the
          parts of your view that have changed.
          
          Now, these examples in and of themselves are fairly useless. The power comes when you want
          to compose them or modify them. If you already have your application running on streams,
          it becomes trivial to change the way the streams flow through your application.
  .el
    table(style="width:100%;"): tr
      td(style="width:50%;")
        h5 Client-side
        code: pre.
          socket = io();
          model = new Thing();
          
          model.asEventStream('change').onValue(function(model){
            socket.emit('change', model.changed);
          });
          socket.on('change', function(delta){
            model.set(delta, {silent:true});
          });
      td(style="width:50%;")
        h5 Server-side
        code: pre.
          io = require('socket.io')(server)
          
          io.on('connection', function(socket){
            socket.on('change', function(delta){
              io.emit('delta');
            });
          });
    .note
      :markdown
        One of the coolest things you can do is incorporate streams with websockets. 
  .el(data-body-class='dark')
    .note Ok. Let's make an app.
  .el(data-body-class='dark')
    h2 Chat server API
    p
      :markdown
        * **GET** `/api/messages?since=<timestamp>` -- fetches messages sent to the server since the given time
        * **POST** `/api/message` `{message:<message>}` -- post a message
    .note
      :markdown
        Suppose you've got an API like this one that's already been written. In reality, WebSockets
        would be the way to go, but for the sake of example, our app is going to work by polling.
        Also, our chat app is just going to be one big chat room for the sake of simplicity.
        
  .el
    script.
      $(function(){
      window.socket.on('custom', function(data){
      console.log(data);
      if(data.initHilite){
      console.log('#init-hilite-'+data.initHilite);
      $('#chat-thread').addClass('dim');
      $('#chat-thread span').css({color:''});
      $('#init-hilite-'+data.initHilite).css({color:'#05a'});
      }
      });
      });
    code#chat-thread: pre.
      ChatThread = Backbone.Collection.extend({
        initialize: function() {<span id="init-hilite-1">
          this.lastSync = this.asEventStream('request')
            .scan(0, () =&gt; + new Date());</span><span id="init-hilite-2">
          this.poll = Bacon.interval(2000);</span><span id="init-hilite-3">
          return this.lastSync
            .sampledBy(this.poll)</span><span id="init-hilite-4">
            .map(function(time) {
              return "/api/messages?since=" + time;
            })</span><span id="init-hilite-5">.flatMap( (url) =&gt; {
              this.trigger('request');
              return Bacon.fromPromise($.getJSON(url));
            })</span><span id="init-hilite-6">.map(function(messages) {
              return messages.map(function(json) {
              return new Message(json);
            });
          })</span><span id="init-hilite-7">.assign(this, 'push');</span>
        }
      });
    .note
      .ui.vertical.buttons
        .ui.green.button(onclick="socket.emit('custom',{initHilite:1})") this.lastSync = ...
        .ui.teal.button(onclick="socket.emit('custom',{initHilite:2})") this.poll = ...
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:3})") ...sampledBy
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:4})") ...map
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:5})") ...flatMap
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:6})") ...map
        .ui.blue.button(onclick="socket.emit('custom',{initHilite:7})") ...assign
    .el
      script(type='x/on-enter').
        $('#chat-box').slideDown();
        var chatThread = new ChatThread();
        var view = new ChatThreadView({collection:chatThread});
        $('#chat-box').append(view.$el);
        $('#chat-box').append((new EntryView()).render().$el)
  .el
    code: pre.
      Message = Backbone.Model.extend({
        send: function() {
          return $.post('/api/message', {message:this.get('content')});
        }
      });
    .note.
      Here's our Message model. It's very simple; it's only got a `send` function hard-coded into
      it. I'd use the Backbone methods if this were a CRUD app, but a chat server isn't quite
      amenable to a CRUD model.
  .el
    h5 Meanwhile, in our View...
    code: pre.
      var keyup = $('#input-field').asEventStream('keyup');
      var clicks = $('#send-button')
      keyup.filter(x =&gt; x===13)
        .merge(clicks)
        .onValue(() =&gt; this.message.send())
  .el
    code: pre.
      ChatThread = Backbone.Collection.extend
        initialize: -&gt;
          @lastSync = @asEventStream('request')
            .scan 0, -&gt; +new Date()
          @poll = Bacon.interval 5000
          @lastSync.sampledBy @poll
            .map (time) -&gt; "/api/messages?since=\#{time}"
            .flatMap (url) -&gt;
              Bacon.fromPromise $.getJSON(url)
            .flatMap (messages) -&gt;
              Bacon.fromArray messages.map (json) -&gt;
                new Message(json)
            .assign @, 'push'
  .el
    h5 Further reading
    .el
      h5: a(href='https://gist.github.com/staltz/868e7e9bc2a7b8c1f754') The intro to Reactive Programming you've been missing
      .note.
        "The intro to Reactive Programming you've been missing" is a gist that explains from the 
        ground up what FRP is in straightforward language. 
    .el
      h5: a(href='http://baconjs.github.io') BaconJS documentation
      .note.
        The BaconJS documentation, of course, is a great place to look. There are a handful of examples
        of most methods, and the homepage has two fully-working examples that give a really good idea
        of how to use all these methods in conjunction with one another.
    .el
      h5: a(href='http://reactive-extensions.github.io/RxJS/') RxJS
      .note
        :markdown
          RxJS is another implementation of FRP, and the one that the Intro to Reactive Programming
          I've listed above uses for its examples.
    .el
      h5: a(href='http://elm-lang.org/') Elm
      h5: a(href='https://github.com/matz/streem') Streem
      .note
        :markdown
          Elm is a little language designed entirely around functional reactive programming. Elm
          gives you these extremely short ways of writing functional reactive programs that compile
          to JavaScript and run in the browser. Some of the examples are almost as hard to read as 
          Haskell programs, but they're very beautiful little programs.
    .el
      h5: a(href='https://github.com/jlongster/js-csp') js-csp
      .note
        :markdown
          Finally, js-csp is a representative of another wildly different form of event handling.
          It implements the communicating sequential processes paradigm, which looks a lot like
          Goroutines, if anyone's played around with Google's Go language. I thought I'd include it
          here in case any of you have already decided you don't like functional reactive and would
          like to see what other directions you can explore for event handling.
          
          That's the whole presentation. I hope I've given you all a good overview of BaconJS,
          how it plays nicely with Backbone, why you may or may not want to use it, and how to use
          it. If anyone has any questions now, I'll be glad to take them.
        
  .shows-over End of presentation.
  
  .ui.segment(style="display:none;")#chat-box
    .ui.top.attached.label Chat thread
    //.ui.bottom.attached.label.field(style="padding:0;")
      .ui.small.action.input(style="width:100%;")
        input(type="text", placeholder="Type your message")
        .primary.ui.button Send
  
  script(src='/socket.io/socket.io.js')
  script(src='/js/vendor/Bacon.js')
  script(src='/js/vendor/underscore.js')
  script(src='/js/vendor/backbone.js')
  script(src='/js/backbone.eventstreams.js')
  script(src='/js/keychar.js')
  script(src='/js/bubbles.js')
  script(src='/js/prez.js')
  script(src='/js/chat.js')
